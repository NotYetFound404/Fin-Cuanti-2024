---
title: "Alto Voltaje"
author: 
  - name: Alicia Sanchez Alberca
  - name: César García Asto
  - name: Daniel Aguilar Paucar
  - name: Giuliano Morales Moreyra
format: 
  html:
    toc: true
    toc_depth: 6
    embed-resources: true
    code-fold: show
    error: false
    warning: false
    code-tools: true
    code-copy: true
    df-print: paged
    code-overflow: wrap
    code-line-numbers: true
    theme: simplex
    fontsize: 1.2em
    linestretch: 1.7
    mainfont: Helvetica Neue, Helvetica, Arial, sans
    monofont: Cascadia Mono, Menlo, Consolas, Courier New, Courier
    backgroundcolor: "white"
    fontcolor: "black"
editor: visual
output: true
---

# Introduction

In this document, we will explore the creation and simulation of a card game using R programming. The task involves developing several functions, including creating a card deck with randomized values, dealing cards to players, initializing the game state, shuffling the discard pile, playing cards strategically, and simulating the game to track the average time the computations take. Through these functions and simulations, we aim test if a bot could hinder the games success.

# Functions

1.  **create_card_deck**
    -   Input: amount of cards that the game will have (default value 73)
    -   Output: dataframe with main number and modifier
2.  **deal_cards**
    -   Input: number of players (default value 2), the number of cards to be dealt, the minimum number of cards that will go on the discard pile
    -   Output: vector with cards for each player and cards on discard pile. Represented with numbers 1 to the number of players, and 0 for the discard pile
3.  **initialize_game**
    -   Input: dataframe of a deck of cards from create_card_deck, vector from deal_cards
    -   Output: list with Players (dataframe representin each player's hand and its corresponding values) and Discard Pile (dataframe)
4.  **shuffle_discard_pile**
    -   Input: the initialized game that contains the discard pile dataframe

    -   Output: the initialized game with a shuffled discard pile dataframe and a z-index colum
5.  **play_card**
    -   Input: player's hand, discard pile

    -   Output: update player's hand and discard pile based on playable card
6.  **simulate_game**
    -   Input: game state
    -   Output: time taken to empty player's hand

# Implementation

## **1. `create_card_deck` Function**

```{r}
create_card_deck  <- function(num_cards = 73){
  main_numbers <- round(runif(n = num_cards,min = 1,max = 10))
  modifiers <- round(runif(num_cards, min = 1, max = 3))
  output <- data.frame(main_numbers = main_numbers, modifiers = modifiers)
  return(output)
}
```

**Example:**

```{r}
create_card_deck(num_cards = 5)
```

## **2. `deal_cards` Function**

```{r}
deal_cards <- function(num_players  = 2, num_cards  = 73, min_discard_pile  = 1){
  total_cards_excluding_discard <- num_cards  - min_discard_pile 
  cards_per_player <- total_cards_excluding_discard %/% num_players 
  remaining_cards_for_discard <- num_cards  - cards_per_player*num_players 
  return(c(rep(0, times = remaining_cards_for_discard),
           rep(1:num_players , each = cards_per_player)))
}
```

**Example:**

```{r}
deal_cards(num_players = 2,num_cards = 5,min_discard_pile = 1)

```

## **3. `initialize_game` Function**

```{r}
initialize_game <- function(num_cards = 73, number_of_players = 2, min_discard_pile = 1){
  # Generate 73 cards 
  df <- create_card_deck (num_cards = num_cards)
  #Calculate the cards values before-hand
  df$values_positive <- df$main_numbers + df$modifiers
  df$values_negative <- df$main_numbers - df$modifiers
  df$values_positive <- ifelse(df$values_positive > 10, 1, df$values_positive)
  df$values_negative <- ifelse(df$values_negative < 0, 8, df$values_negative)
  
  # Add a unique identifier column
  df$card_id <- seq_len(nrow(df))
  # Deal the cards(Decide which cards are assigned to whom)
  card_holder <- deal_cards(num_players = number_of_players, num_cards = num_cards, min_discard_pile  = min_discard_pile)
  # Group the dataframe by card_holder and split into list
  df_split <- split(df, card_holder)
  # Create output list with discard pile and players' hands
  output <- list(
    "Discard_Pile" = df_split[[1]],  # Using [[0]] for the discard pile (card_holder = 0)
    "Players" = df_split[-1]  # Rest of the groups correspond to players
  )
  return(output)
}
```

**Example:**

```{r}
initialize_game(num_cards = 10,number_of_players = 2,min_discard_pile = 1)
```

## **4. `shuffle_discard_pile` Function**

```{r}
shuffle_discard_pile  <- function(game_state){
  game_state$Discard_Pile <- sample(game_state$Discard_Pile, replace = FALSE)
  #Adds z-index to keep track of which card is on top
  game_state$Discard_Pile$z_index <- seq_len(nrow(game_state$Discard_Pile))
  return(game_state)
}
```

**Example:**

```{r}
game <- initialize_game(num_cards = 6,number_of_players = 2, min_discard_pile = 2)
shuffled_game <- game |> shuffle_discard_pile()
#Print original discard pile
game$Discard_Pile
#Print shuffled discard pile
shuffled_game$Discard_Pile
```

## **5. `play_card` Function**

```{r}
play_card <- function(game_state, player_id = "1") {
  library(dplyr)
  # Extract the discard pile and players' hands from game_state
  discard_pile <- game_state$Discard_Pile
  players_hands <- game_state$Players[[player_id]]
  
  # Grab the card on the highest z-index in the discard pile
  top_card <- game_state$Discard_Pile[which.max(game_state$Discard_Pile$z_index), ]
  
  # Find playable cards based on the top card on the discard pile
  top_card_values <- c(top_card$values_positive, top_card$values_negative)
  
  # Check if players_hands is not NULL before filtering
  if (!is.null(players_hands)) {
    playable_cards <- players_hands |>
      filter(values_positive %in% top_card_values | values_negative %in% top_card_values)
  } else {
    playable_cards <- NULL
  }
  
  if (!is.null(playable_cards) && nrow(playable_cards) > 0) {
    # Select the first playable card
    card_to_play <- playable_cards[1, ]
    
    # Remove the played card from the player's hand
    players_hands_after <- players_hands |> 
      filter(card_id != card_to_play$card_id)
    
    # Add the selected card to the discard pile
    card_to_discard_pile <- card_to_play |> mutate(z_index = top_card$z_index + 1)
    discard_pile_after <- bind_rows(card_to_discard_pile, discard_pile)
    
    # Update game_state with the modified discard pile and player's hand
    game_state$Discard_Pile <- discard_pile_after
    game_state$Players[[player_id]] <- players_hands_after
    game_state$card_to_play <- "There a card to play"
    output <- game_state
  } else {
    game_state$card_to_play <- "There is no possible play"
    output <- game_state
  }
  return(output)
}
```

**Example:**

```{r}
game <- initialize_game(num_cards = 10,number_of_players = 1,min_discard_pile = 1) |> shuffle_discard_pile()
game_after_player1_turn <- game |> play_card()
#Let's compare player1's hand before playing
game$Players[["1"]]
#After playing, player1's hand is changed!
game_after_player1_turn$Players[["1"]]
#Has there been any changes?
!identical(game$Players[["1"]],game_after_player1_turn$Players[["1"]])
#Yes, the players hand has changed

```

## **6. `simulate_game` Function**

```{r}
simulate_game <- function(game_state, player_id){
  library(tictoc)
  tic(quiet = T)
  # Perform the first step
  step1 <- play_card(game_state = game_state, player_id = player_id)
  # Repeat until there is no possible play
  repeat {
    # Check if the card to play is "There is no possible play"
    if (step1$card_to_play == "There is no possible play") {
      # Exit the loop if there's no possible play
      break
    } else {
      # Perform the next step
      step1 <- play_card(game_state = step1, player_id = player_id)
    }
  }
  step1[["time_taken"]] <- toc(quiet = T)
  return(step1)
}

```

**Example:**

```{r}
game <- initialize_game(num_cards = 10,number_of_players = 1,min_discard_pile = 1)|>shuffle_discard_pile()
finished_game <- simulate_game(game_state = game,player_id = "1")


#Let's compare the discard pile before playing
game$Discard_Pile
#After playing, discard pile will have changed!
finished_game$Discard_Pile
#Has there been any changes?
!identical(game$Discard_Pile, finished_game$Discard_Pile)
#Yes, the players has finished playing and the discard pile has new cards on top

#We can also see how much time this to play this game took
finished_game$time_taken

```

Implement each function with code examples and explanations. Use code blocks for clarity and include comments where necessary.

# Simulation of a one-player game

Perform the one player game simulation and track the time taken to empty the hand. Repeat the simulation 1 million times, generating a new set of cards each time. Use a time tracking package like tictoc. Calculate and display the average time taken for each run. Optionally, award an additional point for the best time.

# Playing one time

```{r}
game <- initialize_game(num_cards = 73, number_of_players = 1, min_discard_pile = 1) |> 
      shuffle_discard_pile() |> 
      simulate_game(player_id = "1")

game
```

# Playing many times

```{r}
# n = 10
# games_list <- purrr::map(1:n, ~ initialize_game(num_cards = 73, number_of_players = 1, min_discard_pile = 1) |> shuffle_discard_pile())
# #Play the games with vectorization
# played_games <- purrr::map(games_list, ~ simulate_game(.x, "1"))

# library(future)
# library(purrr)
# Set up parallel processing
# plan(strategy = multisession(workers =availableCores()-1))
# n = 10
# games_list <- future_map(1:n, ~ initialize_game(num_cards = 73, number_of_players = 1, min_discard_pile = 1) |> shuffle_discard_pile(),.options = furrr_options(seed = T,scheduling = 2, chunk_size = NULL))
# #Play the games with vectorization
# 
# played_games <- future_map(games_list, ~ simulate_game(.x, "1"),.options = furrr_options(seed = T,scheduling = 2, chunk_size = NULL))


```

\
Get the average compute time each game took

```{r}
# compute_times <- purrr::map_dbl(played_games, ~ .x$time_taken$toc - .x$time_taken$tic)
# mean(compute_times)

```

# Conclusion

Summarize the results and any observations made during the simulations. Mention any improvements or further enhancements that could be made to the code or simulation process.

# Appendix (Optional)

Include additional code snippets, data visualizations, or any supplementary information that adds value to the document.
