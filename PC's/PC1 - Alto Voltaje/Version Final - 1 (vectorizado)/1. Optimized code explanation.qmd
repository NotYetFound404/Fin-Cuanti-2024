---
title: "Alto Voltaje"
author: 
  - name: Alicia Sanchez Alberca
  - name: César García Asto
  - name: Daniel Aguilar Paucar
  - name: Giuliano Morales Moreyra
format: 
  html:
    toc: true
    toc_depth: 6
    embed-resources: true
    code-fold: true
    error: false
    warning: false
    code-tools: true
    code-copy: true
editor: visual
output: asis
theme: cosmo 
---

## **One-Person Game**

This code snippet simulates a one-person game using optimized functions sourced from a specific file path.

### **Functionality**

1.  **Initialize Game**: Creates a game instance with the specified parameters.

    -   **`num_cards`**: Number of cards in the game.

    -   **`number_of_players`**: Number of players in the game (in this case, 1).

    -   **`min_discard_pile`**: Minimum size of the discard pile.

2.  **Shuffle Discard Pile**: Shuffles the discard pile of the game.

3.  **Simulate Game**: Simulates the game for a single player.

    -   **`player_id`**: Identifier for the player (in this case, "1").

```{r}
source(paste0(getwd(), "/PC's/PC1 - Alto Voltaje/Version Final - 1 (vectorizado)/optimized_functions.R"))

# Initialize, shuffle, and simulate the game
game <- initialize_game(num_cards = 73, number_of_players = 1, min_discard_pile = 1) |>
  shuffle_discard_pile() |>
  simulate_game(player_id = "1")
```

### **Output**

-   **`discard_pile`**: Information about the discard pile in the game.

-   **`players_info`**: Information about the players in the game (in this case, only one player).

-   **`card_to_play`**: The card selected to play in the game.

```{r}
# Retrieve game information
discard_pile <- game$Discard_Pile
players_info <- game$Players
card_to_play <- game$card_to_play

# Output the game's discard pile, player information, and the card to play
print(discard_pile)
print(players_info)
print(card_to_play)
```

In depth detail of each function:

```{r}
v
```

## **Parallel Game Simulation Documentation**

**UNA BUENA IDEA ES SIMULAR DE 1000 EN 1000 JUEGOS DE MANERA PARELELA**

This function performs a parallel simulation of the game using the specified number of simulations (**`n_sim`**). It utilizes multiple cores for faster computation.

### **Usage**

```         
parallel_simulation(n_sim)
```

### **Parameters**

-   **`n_sim`**: Numeric. Number of simulations to run.

### **Required Packages**

-   **`foreach`**: For parallel iteration.

-   **`doParallel`**: For parallel backend.

-   **`parallelly`**: For detecting the correct number of cores.

-   **`tictoc`**: For measuring execution time.

-   **`ggplot2`**: For creating visualizations.

### **Function Flow**

1.  Load required libraries.

2.  Source optimized functions from a specific file path.

3.  Set up parallelization with all available cores minus one.

4.  Export necessary functions to parallel workers.

5.  Perform *n_sim* **individual game simulations** in parallel.

6.  Calculate and return the time taken for each simulation.

7.  Stop the cluster after computations.

### **Example 1:**

```{r}
n_sim <- 10
tictoc::tic()
re <- parallel_simulation(n_sim = n_sim)
total_time <- tictoc::toc()
print(paste0("Total compute time: ", total_time$callback_msg))
print(paste0("Average compute time per simulation: ", mean(re)))
```

### **Visualization**

Plot the data into a histogram using **`ggplot2`** to visualize the distribution of computation times across simulations.

```{r}
library(ggplot2)
p <- ggplot(data = data.frame(time=re), aes(x = time)) +
  geom_histogram() +  # Adjust binwidth as needed
  labs(x = "Time (seconds)", y = "Frequency", title = "Computation Time Histogram")
p

```
