---
title: "Alto Voltaje"
author: 
  - name: Alicia Sanchez Alberca
  - name: César García Asto
  - name: Daniel Aguilar Paucar
  - name: Giuliano Morales Moreyra
format: 
  html:
    toc: true
    toc_depth: 6
    embed-resources: true
    code-fold: true
    error: false
    warning: false
    code-tools: true
    code-copy: true
editor: visual
output: asis
theme: cosmo 
---

**Card Deck**

The card deck is generated according to the following logic:

-   "There are 73 cards. Each card has a main number from 1 to 10 and a modifier number ± 1 to 3"

```{r}
# # Create the main numbers and modifiers
# main_numbers <- 1:10
# modifiers <- c((-1:-3), (1:3))
# 
# # Generate all combinations
# card_deck <- expand.grid(Main_Number = main_numbers, Modifier = modifiers) |> dplyr::mutate(Value = Main_Number + Modifier)
```

## 1. Creating a stochastic 73 card deck

```{r}
# draw_n_cards <- function(n = 73){
#   #1. equal probability of drawing a card with numbers 1 trough 10
#   
#   main_numbers <- round(runif(n = n,min = 1,max = 10))
#   main_numbers
#   
#   #2. equal probability of drawing a card with numbers -1 trough -3 and 1 trough 3
#   #ARREGLAR, ES POSIBLE QUE TENGA UN NUMERO DE 1 A 3 INDEPENDIENTEMENTE PERO TODOS TIENEN AMBOS VALORES + Y - 
#   #2.1 Generate n positive and negative values
#   modifiers_pos <- round(runif(n, min = -3, max = -1))
#   modifiers_neg <- round(runif(n, min = 1, max = 3))
#   #2.2 Randomly choose n from both positive and negative values
#   modifiers <- c(modifiers_pos, modifiers_neg)
#   modifiers <- sample(x = modifiers,size = n)
#   modifiers <- modifiers
#   
#   #hay que hacer que sea valor absoluto y cuando calcule el valor añadir las columnas +1 y -1 para ambos valores
#   
#   #3. Output Dataframe
#   output <- data.frame(main_numbers = main_numbers, modifiers = modifiers)
#   return(output)
# }
```

Modificado para que el modificador solo sea en valor absoluto

```{r}
draw_n_cards <- function(n = 73){
  #1. equal probability of drawing a card with numbers 1 trough 10
  
  main_numbers <- round(runif(n = n,min = 1,max = 10))
  main_numbers
  
  #2. equal probability of drawing a card with absolute modifier values of1 trough 3
  modifiers <- round(runif(n, min = 1, max = 3))
  
  #hay que hacer que sea valor absoluto y cuando calcule el valor añadir las columnas +1 y -1 para ambos valores
  
  #3. Output Dataframe
  output <- data.frame(main_numbers = main_numbers, modifiers = modifiers)
  return(output)
}
```

Testing

```{r}
# a <- draw_n_cards()
# a
```

## 2. Draw n cards for m-players

Si cada jugador debe sacar por ejemplo 73 cartas

```{r}
# draw_n_cards_for_m_players <- function(n = 10, m = 2){
#   cards <- list()
#   for(i in 1:m){
#     player_name <- paste0("Player_",i) 
#     cards_drawn <- draw_n_cards(n = n) |> 
#       dplyr::mutate(player_name = player_name)
#     cards[[player_name]] <- cards_drawn
#   }
#   return(cards)
# }
# test <- draw_n_cards_for_m_players(n = 73, m = 2)
```

Se creo un vector ordenado con el numero de cartas a repartir a cada jugador (enumerado desde 1 hasta el numero de jugadores) y 0 a la pila de descarte

```{r}
draw_n_cards_for_m_players <- function(player_number = 2, n_cards_on_deck = 73, discard_pile_minimum = 1){
  
  #There's always one card on the discard pile
  cards_to_discard_pile <- discard_pile_minimum
  #After accounting for the card on the discard pile, theres a new number of available cards
  available_cards <- n_cards_on_deck - cards_to_discard_pile
  #Each player will be have the following cards
  cards_for_each_player <- round(available_cards/player_number)
  #When there's an uneven number of platers,more cards will be added to the discard pile
  cards_to_discard_pile <- cards_to_discard_pile + (available_cards %% player_number)
  
  #Output= Vector that contains the number of cards for each player and for the discard pile
  #0: to the discard pile
  #1 to n: number of players
  Vec <- c(rep(0, each = cards_to_discard_pile),
           rep(1:player_number, each = cards_for_each_player))
  return(Vec)
}
```

## 3. Juntar

```{r}
fn_anon <- function(n_cards_on_deck = 73, number_of_players = 2, initial_discard_pile = 1){
  #Generate 73 cards 
  df <- draw_n_cards(n = n_cards_on_deck)
  #Decide which cards are to whom
  card_holder <- draw_n_cards_for_m_players(player_number = number_of_players,n_cards_on_deck = n_cards_on_deck,discard_pile_minimum = initial_discard_pile)
  #Assign the cards to each card holder 
  df <- df |> dplyr::mutate(
    card_holder = card_holder
  )
  #Turn df into a list
  df_list <- split(df, df$card_holder)
  return(df_list)
}
```

test

```{r}
game_before_shuffling <- fn_anon(n_cards_on_deck  = 5,number_of_players = 1,initial_discard_pile = 2)
```

## 4. Shuffle the discard pile

```{r}
#Check if shuffling logic works
# original <- test[["1"]] |> dplyr::mutate(index = seq_along(original$card_holder))
# original_shuffled <- original |> dplyr::sample_n(size = nrow(original),replace = F)
```

```{r}
suffle_discard_pile <- function(df_list, debug_mode = F){
  if(debug_mode == T){
    #Debug mode adds the index in the original discard pile (it should be different when shuffled)
  #Original data: uses the "0" because this represents the discard pile
  original <- df_list[["0"]] |> dplyr::mutate(index = seq_along(original$card_holder))
  original_shuffled <- original |> dplyr::sample_n(size = nrow(original),replace = F)
  
  #Dont change the discard pile, add the original discard pile with index and with shuffling
  df_list[["original"]] <- original
  df_list[["original_shuffled"]] <- original_shuffled
  
  } else{
  original <- df_list[["0"]]
  original_shuffled <- original |> dplyr::sample_n(size = nrow(original),replace = F)
  #Add a z-index to determine which card is on top (higher z-index means it is closer to the top, lower is lower)
  original_shuffled <- original_shuffled |> dplyr::mutate(z_index = seq_along(original_shuffled$card_holder))
  
  #Only change the discard pile
  df_list[["0"]] <- original_shuffled
  }
  return(df_list)
}
```

Testing the shuffling function

```{r}
game_after_shuffling <- suffle_discard_pile(df_list = game_before_shuffling)
```

## 5. Function that looks at hand and plays

First we need to calculate the values that a card can take. Because the modifier has a +/- symbol it can take both values

```{r}
calc_value <- function(df){
  output <- df |> dplyr::mutate(
    modifier_positive = modifiers,
    modifier_negative = -modifiers,
  Value_positive = main_numbers + modifier_positive,
  Value_negative = main_numbers + modifier_negative) |> dplyr::mutate(
    #Case when there is a positive overflow
    Value_positive = ifelse(Value_positive > 10, 1,Value_positive),
    #Case when there is a negative overflow
    Value_negative = ifelse(Value_positive < 0, 8,Value_negative)
)
  return(output)
}

rm_calc <- function(df){
  output <- df |> dplyr::select(
    -modifier_positive,
    -modifier_negative,
    -Value_positive,
    -Value_negative)
  return(output)
}

```

```{r}
# #---------------
# #1. Grab the card on the highest z-index in the discard pile
# top_Card_on_discard_pile <- game_after_shuffling[["0"]][which.max(game_after_shuffling[["0"]]$z_index), ]
# #top_Card_on_discard_pile
# 
# #2. Look at my hand
# my_hand <- game_after_shuffling[["1"]]
# 
# #3. calculate the card's value with the modifier
# #3.1 Compute my cards value
# my_hand <- calc_value(my_hand)
# #3.2 Compute the value of the card on top of the discard pile
# top_Card_on_discard_pile <- calc_value(top_Card_on_discard_pile)
# 
# #View(my_hand)
# #View(top_Card_on_discard_pile)
# 
# #4. Store playable cards
# #4.1 Posible Cards to match belong to card on top
# cards_to_match <- c(top_Card_on_discard_pile$Value_positive,
#                     top_Card_on_discard_pile$Value_negative)
# #4.2 Cards in my deck that match either value of the card on top's main number +/- its modifier
# playable_cards <- my_hand |> dplyr::filter(
#   Value_positive %in% cards_to_match | Value_negative %in% cards_to_match)
# #4.3 Select the card that will be played
# #Selection criteria = the first that comes up if there are any
# if(dim(playable_cards)[1] > 0){
#   #select card to play
#   card_to_play <- dplyr::first(playable_cards)
#   # Remove played card
#   my_hand_after <- dplyr::anti_join(my_hand, card_to_play, by = c("main_numbers", "modifiers"))
#   # Add the selected card to the discard pile
#   card_to_play <- card_to_play |> dplyr::mutate(
#     z_index = top_Card_on_discard_pile$z_index + 1 #Adjust the z-index
#   )
#   discard_pile_after <- dplyr::bind_rows(card_to_play, discard_pile)
#    
# } else{
#   card_to_play <- NULL
#   print("There is no possible play")
# }
```

```{r}
# #1. Grab the card on the highest z-index in the discard pile
# discard_pile <- game_after_shuffling[["0"]]
# top_Card_on_discard_pile <- discard_pile[which.max(game_after_shuffling[["0"]]$z_index), ]
# #top_Card_on_discard_pile
# 
# #2. Look at my hand
# my_hand <- game_after_shuffling[["1"]]
# 
# #3. calculate the card's value with the modifier
# #3.1 Compute my cards value
# my_hand <- calc_value(my_hand)
# #3.2 Compute the value of the card on top of the discard pile
# top_Card_on_discard_pile <- calc_value(top_Card_on_discard_pile)
# 
# #View(my_hand)
# #View(top_Card_on_discard_pile)
# 
# #4. Store playable cards
# #4.1 Posible Cards to match belong to card on top
# cards_to_match <- c(top_Card_on_discard_pile$Value_positive,
#                     top_Card_on_discard_pile$Value_negative)
# #4.2 Cards in my deck that match either value of the card on top's main number +/- its modifier
# playable_cards <- my_hand |> dplyr::filter(
#   Value_positive %in% cards_to_match | Value_negative %in% cards_to_match)
# #4.3 Select the card that will be played
# #Selection criteria = the first that comes up if there are any
# if(nrow(playable_cards) > 0){
#   #select card to play
#   card_to_play <- dplyr::first(playable_cards)
#   # Remove played card
#   my_hand_after <- dplyr::anti_join(my_hand, card_to_play, by = c("main_numbers", "modifiers"))
#   
#   # Remove calculation on my hand
#   my_hand_after <- rm_calc(df = my_hand_after)
#   
#   #rm calculation on card_to play
#   card_to_play <- rm_calc(card_to_play)
#   # Add the selected card to the discard pile
#   card_to_play <- card_to_play |> dplyr::mutate(
#     z_index = top_Card_on_discard_pile$z_index + 1 #Adjust the z-index
#   )
#   discard_pile_after <- dplyr::bind_rows(card_to_play, discard_pile)
#   
# } else{
#   card_to_play <- NULL
#   print("There is no possible play")
# }
```

As a function

 

```{r}
fn_anon2 <- function(my_hand_input_df = game_after_shuffling[["1"]],discard_pile_input_df = game_after_shuffling[["0"]]){
  #1. Grab the card on the highest z-index in the discard pile
  discard_pile <- discard_pile_input_df 
  top_Card_on_discard_pile <- discard_pile[which.max(game_after_shuffling[["0"]]$z_index), ]
  #2. Look at my hand
  my_hand <- my_hand_input_df
  #3. calculate the card's value with the modifier
  #3.1 Compute my cards value
  my_hand <- calc_value(my_hand)
  #3.2 Compute the value of the card on top of the discard pile
  top_Card_on_discard_pile <- calc_value(top_Card_on_discard_pile)
  #4. Store playable cards
  #4.1 Posible Cards to match belong to card on top
  cards_to_match <- c(top_Card_on_discard_pile$Value_positive,
                      top_Card_on_discard_pile$Value_negative)
  #4.2 Cards in my deck that match either value of the card on top's main number +/- its modifier
  playable_cards <- my_hand |> dplyr::filter(
    Value_positive %in% cards_to_match | Value_negative %in% cards_to_match)
  #4.3 Select the card that will be played
  #Selection criteria = the first that comes up if there are any
  if(nrow(playable_cards) > 0){
    #select card to play
    card_to_play <- dplyr::first(playable_cards)
    # Remove played card
    my_hand_after <- dplyr::anti_join(my_hand, card_to_play, by = c("main_numbers", "modifiers"))
    # Remove calculation on my hand
    my_hand_after <- rm_calc(df = my_hand_after)
    #rm calculation on card_to play
    card_to_play <- rm_calc(card_to_play)
    # Add the selected card to the discard pile
    card_to_play <- card_to_play |> dplyr::mutate(
      z_index = top_Card_on_discard_pile$z_index + 1 #Adjust the z-index
    )
    discard_pile_after <- dplyr::bind_rows(card_to_play, discard_pile)
    
    #Return a list
    output <- list(my_hand_after = my_hand_after, discard_pile_after = discard_pile_after)
  } else{
    card_to_play <- NULL
    print("There is no possible play")
    
    #Return a list
    output <- list(my_hand_after = my_hand, discard_pile_after = discard_pile)
  }
  return(output)
}
```

Testing 5

```{r}
View(game_after_shuffling)
test  <-  fn_anon2()
View(test)
```

Re test

```{r}
test2  <-  fn_anon2(my_hand_input_df = test$my_hand_after,discard_pile_input_df = test$discard_pile_after )
```

Re test 2

```{r}
test3  <-  fn_anon2(my_hand_input_df = test2$my_hand_after,discard_pile_input_df = test2$discard_pile_after )
```
