---
title: "Time Series Analysis and Forecasting"
author: 
  - name: Alicia Sanchez Alberca
  - name: César García Asto
  - name: Daniel Aguilar Paucar
  - name: Giuliano Morales Moreyra
format: 
  html:
    toc: true
    toc_depth: 6
    embed-resources: true
    code-fold: show
    error: false
    warning: false
    code-tools: true
    code-copy: true
    df-print: paged
    code-overflow: wrap
    code-line-numbers: true
    theme: simplex
    fontsize: 1.2em
    linestretch: 1.7
    mainfont: Helvetica Neue, Helvetica, Arial, sans
    monofont: Cascadia Mono, Menlo, Consolas, Courier New, Courier
    backgroundcolor: "white"
    fontcolor: "black"
editor: visual
output: true
---

# Setup

First, we need to load the necessary libraries for the analysis.

```{r}
library(tidyverse)
library(tidyquant)
library(timetk)
library(rugarch)
```

Then, we'll load some helper functions.

```{r}
smape <- function(a, f) {  return (1/length(a) * sum(2*abs(f-a) / (abs(a)+abs(f))*100))}
train_test_split_cutoff <- function(data, date_col, cutoff_date) {
  library(timetk)
  
  # Check if the input data is a dataframe
  if(!is.data.frame(data)) {
    stop("Input data is not a dataframe")
  }
  
  
  date_expr <- enquo(date_col)
  train.df <- data %>%
    filter(!!date_expr <= as.Date(cutoff_date))
  test.df <- data %>%
    filter(!!date_expr > as.Date(cutoff_date))
  return(list(data.df = data,
              data.xts = tk_xts(data, select = -{{date_col}}, date_var = {{date_col}}),
              train.df = train.df,
              train.xts = tk_xts(train.df, select = -{{date_col}}, date_var = {{date_col}}),
              test.df = test.df,
              test.xts = tk_xts(test.df, select = -{{date_col}}, date_var = {{date_col}})))
} 
plot_ts <- function(data, x_col, y_col, plot_title = "Time series plot", x_label = "Date", y_label = "Values",date_breaks = "1 month",date_format = "%m-%Y") {
  ## DATE BREAKS:
  # Yearly breaks:
  #   "1 year": Breaks by year.
  # "2 years": Breaks by every two years.
  # "5 years": Breaks by every five years.
  # Monthly breaks:
  #   "1 month": Breaks by month.
  # "2 months": Breaks by every two months.
  # "3 months": Breaks by every three months.
  # Weekly breaks:
  #   "1 week": Breaks by week.
  # "2 weeks": Breaks by every two weeks.
  # "4 weeks": Breaks by every four weeks.
  # Daily breaks:
  #   "1 day": Breaks by day.
  # "2 days": Breaks by every two days.
  # "3 days": Breaks by every three days.
  
  ## DATE FORMATING:
  # Year and Month:
  #   %Y-%m: 2022-01, 2022-02, etc.
  # %Y/%m: 2022/01, 2022/02, etc.
  # %Y %b: 2022 Jan, 2022 Feb, etc. (abbreviated month name)
  # %Y %B: 2022 January, 2022 February, etc. (full month name)
  # Month and Year:
  #   %m-%Y: 01-2022, 02-2022, etc.
  # %b-%Y: Jan-2022, Feb-2022, etc. (abbreviated month name)
  # %B-%Y: January-2022, February-2022, etc. (full month name)
  # Day, Month, and Year:
  #   %d-%m-%Y: 01-01-2022, 02-01-2022, etc.
  # %d/%m/%Y: 01/01/2022, 02/01/2022, etc.
  # %d %b %Y: 01 Jan 2022, 02 Jan 2022, etc. (abbreviated month name)
  # %d %B %Y: 01 January 2022, 02 January 2022, etc. (full month name)
  # Day of the Week:
  #   %A: Monday, Tuesday, etc. (full weekday name)
  # %a: Mon, Tue, etc. (abbreviated weekday name)
  # Hour, Minute, and Second (for timestamps):
  #   %H:%M:%S: 12:30:45 (24-hour format)
  # %I:%M:%S %p: 12:30:45 PM (12-hour format with AM/PM)
  # Ordinal Dates:
  #   %j: Day of the year (001 to 366)
  # %U: Week number of the year (00 to 53, starting with Sunday)
  # %W: Week number of the year (00 to 53, starting with Monday)
  # %Y-%m-%d %H:%M:%S: 2022-01-01 12:30:45 (date and time)
  # %d %b %Y, %A: 01 Jan 2022, Saturday (date and weekday)
  # %H:%M:%S %p: 12:30:45 PM (time with AM/PM)
  
  ggplot(data, aes(x = {{x_col}}, y = {{y_col}})) +
    geom_line() +
    labs(x = x_label, y = y_label, title = plot_title) +
    scale_x_date(date_breaks =date_breaks, date_labels = date_format) + 
    theme_minimal()
}
```

# 1. Download and load the crypto dataset

We will download the dataset from the following link: [Crypto dataset](https://www.kaggle.com/sudalairajkumar/cryptocurrencypricehistory). The dataset contains historical data on the price of cryptocurrencies.

```{r}
# Replace 'path/to/your/file.csv' with the actual path to your CSV file
df <- read.csv("C:/Users/RYZEN7/Desktop/crypto-markets.csv")
```

#2. The strategy will start with analyzing the main crypto by market cap so filter only for that one

```{r}
# Calculate the average market capitalization for each symbol in each year
yearly_avg_market_cap <- df %>%
  mutate(year = year(ymd(date))) %>%
  group_by(year, symbol) %>%
  summarize(average_market_cap = mean(market)) %>% 
  arrange(desc(average_market_cap))

# Calculate the overall average market capitalization for each symbol
overall_avg_market_cap <- yearly_avg_market_cap %>%
  group_by(symbol) %>%
  summarize(overall_average_market_cap = mean(average_market_cap, na.rm = TRUE)) %>%
  arrange(desc(overall_average_market_cap))
highestMarketCap <- overall_avg_market_cap[[1]][[1]]
BTc <- df %>% filter(symbol == highestMarketCap) %>% mutate(date = date(date))
rm(yearly_avg_market_cap,overall_avg_market_cap,df)
```

#3. You can choose the frequency of data you want to work with (daily, weekly, monthly, etc). Explain why

We will work with daily data because it provides more detailed information about the price movements of the cryptocurrency.

```{r}
BTC.dailyRet <- BTc %>%
  tq_transmute(select = close,
               mutate_fun = periodReturn,
               period = 'daily',
               col_rename = 'ret',
               type = 'log')
```

#4. Split the data into training and test. Last date of training should be 2017-05-31.

```{r}
BTC.split <- train_test_split_cutoff(BTC.dailyRet, date, '2017-05-31')
```

#5. Plot the data and explain the characteristics this process displays.

```{r}
# Plot the time series of the closing price of the cryptocurrency
plot_ts(BTc, date, close, "Time Series of Bitcoin Closing Price", "Date", "Closing Price (USD)")

#plot the daily returns
plot(tk_xts(BTC.dailyRet), main = "BTC Daily Returns")

#plot the train
plot(BTC.split$train.xts, main = "BTC Daily returns (train)", col = "blue")

#plot the test
plot(BTC.split$test.xts, main = "BTC Daily returns (test)", col = "red")

```

#6. Do the necessary transformations to get a stationary time series.
#testing for stationarity

#taking the first diference




```{r}
# Plot the time series of the closing price of the cryptocurrency
plot_ts(BTC.split$data.df, date, close, "Time Series of Bitcoin Closing Price", "Date", "Closing Price (USD)")
plot_ts(BTC.split$train.df, date, close, "Time Series of Bitcoin Closing Price (Training Data)", "Date", "Closing Price (USD)")
plot_ts(BTC.split$test.df, date, close, "Time Series of Bitcoin Closing Price (Test Data)", "Date", "Closing Price (USD)")
```

```{r}
# Augmented Dickey-Fuller test for stationarity
adf.test(BTC.split$train.xts$close)
```

```{r}
# First difference
BTC.diff <- diff(BTC.split$train.xts$close)
plot(tk_tbl(BTC.diff), main="Time Series of Bitcoin Closing Price (First Difference)", "Date", "Closing Price (USD)")
```

```{r}
# Augmented Dickey-Fuller test for stationarity
adf.test(BTC.diff)
```
