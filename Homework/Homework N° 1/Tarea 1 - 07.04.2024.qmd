---
title: "Tarea 1"
bibliography: references.bib
format: 
  html:
    toc: true
    embed-resources: true
    code-fold: true
editor: visual
theme: cosmo 
---

# Instructions

1.  Simulate the Vasicek model simulation.

2.  Understand the previous simulations and try to implemented it on your way.

    1.  Standard Brownian Motion

    2.  Brownian Motion

    3.  Geometric Brownian Motion

Also:

-   Explain each part of the code.

-   Use the stochastic equation of the Vasick model

-   Ideas for implementation

    -   Using `replicate`
    -   Using `sapply`
    -   As a matrix without loops or sapply or replicate

# 1. Vasicek Model

The interest rate is modeled by the following equation:

$$
\mathrm{d}r_{t} = a(b - r_{t})\,\mathrm{d}t + \sigma\,\mathrm{d}W_{t}
$$

Source: [@wiki:vasicek]

-   b: Long term mean level
-   a: Speed of reversion
-   sigma : instantaneous volatility

For more detail, check @vanAVR

Revisar <https://hannoreuvers.github.io/post/vasicek/>

Tambien <https://quantgirluk.github.io/Understanding-Quantitative-Finance/intro.html>

## Base implementation

```{r}
n <- 10
m <- 100
T <- 1
dt <- T/n

r <- matrix(0, nrow = m, ncol = n+1)
Z <- matrix(rnorm(m*n), nrow = m, ncol = n)
t <- numeric(n)
r[,1] <-  0.0625
t[1] <- 0

alpha <- 0.4
b <- 0.04
sigma <- 0.1
for(i in 1:n){
  t[i+1]= t[i]+dt
  r[, i + 1] <- r[, i] + alpha*(b - r[, i]) + sigma*sqrt(dt)*Z[, i]
}
library(MASS)
matplot(t, t(r), type = "l")

```

Entiendo que lo anteiror es el proceso, pero esta es la derivacion del modelo (?)\

$$
r_{t} = r_{0}e^{-at} + b(1-e^{-at}) + \sigma e^{-at} \int_{0}^{t} e^{as} \, dW_{s}.
$$

## Implementation 1: Using a *For Loop*

1.  **Initialize Parameters:** First, let's initialize the parameters needed for the model. We'll define b, a, Ïƒ, the time step (dt), the number of time periods (n), and the number of simulations (simulations).

```{r}

b <- 0.05  # Long-term average interest rate
a <- 0.1   # Speed of mean reversion
sigma <- 0.02  # Volatility
dt <- 1/252  # Time step (assuming daily simulations)
n <- 252     # Number of time periods (1 year)
simulations <- 1  # Number of simulations
```

2.  **Initialize Arrays:** Next, let's initialize empty arrays to store the simulated interest rates (r) and time periods (t).

```{r}
r <- numeric(n)  # Array to store interest rates
t <- numeric(n)  # Array to store time periodsx
```

3.  **Simulation Loop:** Now, we'll use a for loop to simulate the Vasicek model for each time period and each simulation. Within the loop, we'll generate random shocks (dW) using a normal distribution and update the interest rate according to the Vasicek model equation.

```{r}

for (i in 1:simulations) {
  r[1] <- b  # Initial interest rate at long-term average
  for (j in 2:n) {
    dW <- rnorm(1, mean = 0, sd = sqrt(dt))  # Random shock
    r[j] <- r[j-1] + a * (b - r[j-1]) * dt + sigma * dW  # Vasicek model equation
    t[j] <- j * dt  # Time period
  }
  plot(t, r, type = "l", col = i, ylim = c(0, 0.1), xlab = "Time", ylab = "Interest Rate", main = "Vasicek Model Simulation")
  lines(t, rep(b, n), col = "red", lty = 2)  # Long-term average line
}

```

4.  **Plotting:** Finally, we'll plot the simulated interest rates over time for each simulation. We'll also add a dashed line representing the long-term average interest rate.

5.  **Explanation:** In the Quarto document, you can explain each step in detail:

Parameter Initialization: Describe the significance of each parameter and how they affect the Vasicek model. Arrays Initialization: Explain why we initialize arrays to store interest rates and time periods. Simulation Loop: Describe how the simulation loop works, including the generation of random shocks and updating the interest rate based on the Vasicek model equation. Plotting: Explain the plotted results, such as the behavior of interest rates over time and the concept of mean reversion represented by the long-term average line.

# 2. Standard Brownian motion

We are modelling using the following equation

$$
W_{i+1} = W_i + \sqrt{t_{i+1} - t_i} \cdot Z_i
$$

$$
W_{i+1} = W_i + \sqrt{d_t} \cdot Z_i
$$

Where:

-   $W_{i+1}$ represents value W at time i+1

-   $W_{i}$ represents value W at time i

-   $t_{i+1}$ and $t_{i}$ represents value time periods

-   $Z_{i}$ represents a random variable at time T

**Algunas equivalencias**

-   dT en un loop = dT usando diff

```{r}
rm(list = ls())

n <-  10
T <- 1
t <- c(0, sort(runif(n, min = 0, max = T)))
dt <- numeric(n)


#With a loop
for (i in 1:n) {
  dt[i] <- sqrt(t[i + 1] - t[i])
}

dt

#without a loop
dt_v2 <- sqrt(diff(t))
dt_v2

#check
all(dt %in% dt_v2)

rm(list = ls())
```

-   Los pasos 1 al 2 pueden son la funcion 'w_setup*'*

```{r}
rm(list = ls())
#originalmente-----------
# Setup
set.seed(2024)
n <- 10000
T <- 1
df <- data.frame(index = seq(1, n+1))

# 1st step
t <- sort(runif(n, min = 0, max = T))
t <- c(0, t)
W <- numeric(n + 1)
W[1] <- 0

# 2nd step
Z <- rnorm(n)



#equivalencia-------------
w_setup <- function(n, T, seed.num = 2024) {
  #setup
  set.seed(seed.num)
  n <- n
  T <- T
  df <- data.frame(index = seq(1, n+1))
  # 1st step
  t <- c(0, sort(runif(n, min = 0, max = T)))
  W <- numeric(n + 1)
  W[1] <- 0
  # 2nd step
  Z <- rnorm(n)
  # save to global env
  assign("df", df, envir = .GlobalEnv)
  assign("n", n, envir = .GlobalEnv)
  assign("t", t, envir = .GlobalEnv)
  assign("T", T, envir = .GlobalEnv)
  assign("W", W, envir = .GlobalEnv)
  assign("Z", Z, envir = .GlobalEnv)
  
}
w_setup(n = 10, T = 1)
rm(list = ls())
```

## Base implementation

```{r}
rm(list = ls())
# Setup -----------
library(ggplot2)
set.seed(2024)
n <- 10000
T <- 1
df <- data.frame(index = seq(1, n+1))
#head(df)

## Standard Brownian motion - Base implementation ------------------------

# 1st step
t <- sort(runif(n, min = 0, max = T))
t <- c(0, t)
W <- numeric(n + 1)
W[1] <- 0

# 2nd step
Z <- rnorm(n)

# 3rd step

for (i in 1:n) {
  W[i + 1] <- W[i] + sqrt(t[i + 1] - t[i])*Z[i]
}


df["t"] <- t
df["W"] <- W

# 4th step
ggplot(data = df, aes(x = t, y = W)) +
  geom_step() +
  labs(
    title = "Standard Brownian motion path simulation",
    x = "Time (years)",
    y = "Brownian motion"
  )
rm(list = ls())

```

Parametros

```{r}
n <- 10
T <- 1
```

## Using sapply

```{r}
source(paste0(getwd(),"/utils.R"))
# Setup -----------
w_setup(n = n, T = T)
# 3rd step
#falta explicar porque funciona
W <- c(0, sapply(2:(n + 1), function(i) {
  W[i - 1] + sqrt(t[i] - t[i - 1]) * Z[i - 1]
}))
#W
df["W"] <- W
df["t"] <- t
# 4th step
ggplot(data = df, aes(x = t, y = W)) +
  geom_step() +
  labs(
    title = "Standard Brownian motion path simulation (sapply)",
    x = "Time (years)",
    y = "Brownian motion"
  )
```

## Using no loops/sapply

```{r}
# Setup -----------
w_setup(n = n, T = T)
# 3rd step
#falta explicar porque funciona

#originalmente
# for (i in 1:n) {
#   W_og[i + 1] <- W_og[i] + sqrt(t[i + 1] - t[i])*Z[i]
# }
# W_og


increments <- sqrt(diff(t)) * Z
W <- c(0, cumsum(increments))

# Add t and W to the data frame
df["t"] <- t
df["W"] <- W

# 4th step
ggplot(data = df, aes(x = t, y = W)) +
  geom_step() +
  labs(
    title = "Standard Brownian motion path simulation (no loops)",
    x = "Time (years)",
    y = "Brownian motion"
  )
```

# 3. Brownian motion

Parameters

```{r}
n <- 100
T <- 1
mu <- 5
sigma <- 2

```

## Sapply implementation

```{r}

source(paste0(getwd(),"/utils.R"))
w_setup(n = n, T = T)


# 3rd step
#falta explicar porque funciona
W <- c(0, sapply(2:(n + 1), function(i) {
  W[i - 1] + sqrt(t[i] - t[i - 1]) * Z[i - 1]
}))

X <- mu*t + sigma*W

df["X"] <- X

ggplot(data = df, aes(x = t, y = X)) +
  geom_step() +
  labs(
    title = "Brownian motion path simulation",
    x = "Time (years)",
    y = "Stock price"
  )

```

# 4. Geometric Brownian motion

Parameters

```{r}

n <- 100
T <- 1

source(paste0(getwd(),"/utils.R"))
w_setup(n = n, T = T)
r <- 0.065
sigma <- 0.45
S <- numeric(n + 1)
S[1] <- 100
```

## Base implementation

```{r}

# 3rd step
for (i in 1:n) {
  S[i + 1] <- S[i]*exp((r - 0.5*sigma^2)*(t[i + 1] - t[i]) + 
  sigma*sqrt(t[i + 1] - t[i])*Z[i])
  
}
df["S"] <- S

ggplot(data = df, aes(x = t, y = S)) +
  geom_step() +
  labs(
    title = "Geometric Brownian motion path simulation",
    x = "Time (years)",
    y = "Stock price"
  )
```

## using sapply

Falta corregir implementacion

```{r}
w_setup(n = n, T = T)
r <- 0.065
sigma <- 0.45
S <- numeric(n + 1)
S[1] <- 100

# 2nd step
Z <- rnorm(n)

S <- c(100,sapply(2:(n+1), function(i){
    S[i] <<- S[i-1]*exp((r - 0.5*sigma^2)*(t[i] - t[i-1]) + 
  sigma*sqrt(t[i] - t[i-1])*Z[i-1])
  }
))

df["S"] <- S

ggplot(data = df, aes(x = t, y = S)) +
  geom_step() +
  labs(
    title = "Geometric Brownian motion path simulation (sapply)",
    x = "Time (years)",
    y = "Stock price"
  )

```
